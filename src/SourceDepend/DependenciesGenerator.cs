using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;
using SourceDepend.Extensions;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Diagnostics;
using System.Linq;
using System.Text;

namespace SourceDepend;

[Generator]
public class DependenciesGenerator : IIncrementalGenerator
{
    private const string attributeText = @"// <auto-generated />
[System.AttributeUsage(System.AttributeTargets.Field | System.AttributeTargets.Property, Inherited = false, AllowMultiple = false)]
[System.Diagnostics.Conditional(""DependencyGenerator_DEBUG"")]
internal sealed class DependencyAttribute : System.Attribute
{
    internal DependencyAttribute(string alternativePropertyName = null) { }
}

";
    private const string attributeDisplayName = "DependencyAttribute";

    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        context.RegisterPostInitializationOutput(context => context.AddSource("Dependency.Generated", attributeText));

        var provider = context.SyntaxProvider.CreateSyntaxProvider(
                    predicate: static (node, _) => node is ClassDeclarationSyntax,
                    transform: static (ctx, _) => ((ClassDeclarationSyntax)ctx.Node, ctx.SemanticModel))
                .Where(m => m.Item1 is not null);

        var compilation = context.CompilationProvider.Combine(provider.Collect());

        context.RegisterSourceOutput(compilation,
            (spc, source) => Execute(spc, source.Right));

    }

    private void Execute(SourceProductionContext context, ImmutableArray<(ClassDeclarationSyntax ClassDeclarationSyntax, SemanticModel SemanticModel)> classes)
    {
        foreach (var classSyntax in classes)
        {
            if (classSyntax.ClassDeclarationSyntax == null || classSyntax.SemanticModel == null)
            {
                continue;
            }

            List<ISymbol>? symbols = null;
            var members = classSyntax.ClassDeclarationSyntax.Members;

            //if (!Debugger.IsAttached) Debugger.Launch();

            foreach (var member in members)
            {
                if (member.AttributeLists.Any() == false)
                {
                    continue;
                }

                if (member is FieldDeclarationSyntax fieldSyntax)
                {
                    foreach (var variable in fieldSyntax.Declaration.Variables)
                    {
                        if (classSyntax.SemanticModel.GetDeclaredSymbol(variable) is ISymbol symbol)
                        {
                            AddSymbolIfTagged(ref symbols, symbol);
                        }
                    }
                }
                else if (member.IsKind(SyntaxKind.PropertyDeclaration))
                {
                    if (classSyntax.SemanticModel.GetDeclaredSymbol(member) is ISymbol symbol)
                    {
                        AddSymbolIfTagged(ref symbols, symbol);
                    }
                }
            }

            if (symbols != null)
            {
                var classSymbol = classSyntax.SemanticModel.GetDeclaredSymbol(classSyntax.ClassDeclarationSyntax);
                if (classSymbol == null)
                {
                    continue;
                }

                var classSource = ProcessClass(classSymbol, symbols);
                if (classSource != null)
                {
                    context.AddSource($"{classSymbol.Name}_Dependency.cs", SourceText.From(classSource, Encoding.UTF8));
                }
            }
        }
    }

    private static void AddSymbolIfTagged(ref List<ISymbol>? symbols, ISymbol fieldSymbol)
    {
        foreach (var att in fieldSymbol.GetAttributes())
        {
            if (att.AttributeClass?.ToDisplayString() == attributeDisplayName)
            {
                symbols ??= [];
                symbols.Add(fieldSymbol);
                break; //break attributes foreach
            }
        }
    }

    private string? ProcessClass(INamedTypeSymbol classSymbol, List<ISymbol> symbols)
    {
        if (!classSymbol.ContainingSymbol.Equals(classSymbol.ContainingNamespace, SymbolEqualityComparer.Default))
        {
            return null; //TODO: issue a diagnostic that it must be top level
        }

        var namespaceName = classSymbol.ContainingNamespace.ToDisplayString();

        // begin building the generated source
        var source = new StringBuilder($@"
namespace {namespaceName}
{{
    public partial class {classSymbol.Name}
    {{
");
        _ = source.Append($"        public {classSymbol.Name}(");
        _ = source.Append(string.Join(", ", GetParams(symbols)));
        _ = source.AppendLine(")");
        _ = source.AppendLine("        {");
        _ = source.AppendLine("            PreConstruct();");
        _ = source.AppendLine();

        foreach (var symbol in symbols)
        {
            switch (symbol)
            {
                case IFieldSymbol field:
                    _ = source.AppendLine($@"            this.{field.Name} = {field.Name.TrimStart('_')};");
                    break;
                case IPropertySymbol property:
                    var name = GetPropName(property, property.GetAttributes());
                    _ = source.AppendLine($@"            {name} = {property.Name.ToCamelCase()};");
                    break;
            }
        }

        _ = source.AppendLine();
        _ = source.AppendLine("            PostConstruct();");
        _ = source.AppendLine("        }");
        _ = source.AppendLine();
        _ = source.AppendLine("        partial void PreConstruct();");
        _ = source.AppendLine("        partial void PostConstruct();");
        _ = source.AppendLine("    }");
        _ = source.AppendLine("}");
        return source.ToString();
    }

    private object? GetPropName(IPropertySymbol prop, ImmutableArray<AttributeData> attributes)
    {
        //System.Diagnostics.Debugger.Launch();

        var dependAttribute = attributes.FirstOrDefault(a => a.AttributeClass?.Name == "DependencyAttribute");
        if (dependAttribute == null)
        {
            return prop.Name;
        }

        var dependArg = dependAttribute.ConstructorArguments.FirstOrDefault();
        if (dependArg.IsNull || dependArg.Kind != TypedConstantKind.Primitive)
        {
            return prop.Name;
        }

        var altName = dependArg.Value as string;
        return string.IsNullOrWhiteSpace(altName) ? prop.Name : (object?)altName;
    }

    private string[] GetParams(List<ISymbol> symbols)
    {
        var variables = new string[symbols.Count];
        for (var i = 0; i < symbols.Count; i++)
        {
            var symbol = symbols[i];
            switch (symbol)
            {
                case IFieldSymbol field:
                    variables[i] = $@"{field.Type} {field.Name.TrimStart('_')}";
                    break;
                case IPropertySymbol property:
                    variables[i] = $@"{property.Type} {property.Name.ToCamelCase()}";
                    break;
            }
        }

        return variables;
    }
}
