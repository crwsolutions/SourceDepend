using System.Collections.Generic;
using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.Text;

namespace SourceDepend;

[Generator]
public class DependenciesGenerator : ISourceGenerator
{
    private const string attributeText = @"// <auto-generated />
[System.AttributeUsage(System.AttributeTargets.Field, Inherited = false, AllowMultiple = false)]
[System.Diagnostics.Conditional(""DependencyGenerator_DEBUG"")]
internal sealed class DependencyAttribute : System.Attribute
{
}

";

    public void Initialize(GeneratorInitializationContext context)
    {
        // Register the attribute source
        context.RegisterForPostInitialization((i) => i.AddSource("Dependency.Generated", attributeText));

        // Register a syntax receiver that will be created for each generation pass
        context.RegisterForSyntaxNotifications(() => new DependenciesReceiver());
    }

    public void Execute(GeneratorExecutionContext context)
    {
        //System.Diagnostics.Debugger.Launch();

        // retrieve the populated receiver 
        if (context.SyntaxContextReceiver is not DependenciesReceiver receiver ||
            receiver?.Fields == null)
        {
            return;
        }

        // group the fields by class, and generate the source
        foreach (var group in receiver.Fields.GroupBy(fieldSymbol => fieldSymbol.ContainingType))
        {
            var classSource = ProcessClass(group.Key, group);
            context.AddSource($"{group.Key.Name}_Dependency.cs", SourceText.From(classSource, Encoding.UTF8));
        }
    }

    private string ProcessClass(INamedTypeSymbol classSymbol, IEnumerable<IFieldSymbol> fields)
    {
        if (!classSymbol.ContainingSymbol.Equals(classSymbol.ContainingNamespace, SymbolEqualityComparer.Default))
        {
            return null; //TODO: issue a diagnostic that it must be top level
        }

        var namespaceName = classSymbol.ContainingNamespace.ToDisplayString();

        // begin building the generated source
        var source = new StringBuilder($@"
namespace {namespaceName}
{{
    public partial class {classSymbol.Name}
    {{
");
        source.Append($"        public {classSymbol.Name}(");
        source.Append(string.Join(", ", GetParams(fields)));
        source.AppendLine(")");
        source.AppendLine("        {");
        source.AppendLine();
        source.AppendLine("            PreInject();");
        source.AppendLine();

        foreach (var field in fields)
        {
            source.AppendLine($@"            this.{field.Name} = {field.Name.TrimStart('_')};");
        }

        source.AppendLine();
        source.AppendLine("            PostInject();");
        source.AppendLine("        }");
        source.AppendLine();
        source.AppendLine("        partial void PreInject();");
        source.AppendLine("        partial void PostInject();");
        source.AppendLine("    }");
        source.AppendLine("}");
        return source.ToString();
    }

    private IEnumerable<string> GetParams(IEnumerable<IFieldSymbol> fields)
    {
        foreach (var fieldSymbol in fields)
        {
            yield return $@"{fieldSymbol.Type} {fieldSymbol.Name.TrimStart('_')}";
        }
    }
}
