using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.Text;
using SourceDepend.Extensions;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Linq;
using System.Text;

namespace SourceDepend;

[Generator]
public class DependenciesGenerator : ISourceGenerator
{
    private const string attributeText = @"// <auto-generated />
[System.AttributeUsage(System.AttributeTargets.Field | System.AttributeTargets.Property, Inherited = false, AllowMultiple = false)]
[System.Diagnostics.Conditional(""DependencyGenerator_DEBUG"")]
internal sealed class DependencyAttribute : System.Attribute
{
    internal DependencyAttribute(string alternativePropertyName = null) { }
}

";

    public void Initialize(GeneratorInitializationContext context)
    {
        // Register the attribute source
        context.RegisterForPostInitialization((i) => i.AddSource("Dependency.Generated", attributeText));

        // Register a syntax receiver that will be created for each generation pass
        context.RegisterForSyntaxNotifications(() => new DependenciesReceiver());
    }

    public void Execute(GeneratorExecutionContext context)
    {
        //System.Diagnostics.Debugger.Launch();

        // retrieve the populated receiver 
        if (context.SyntaxContextReceiver is not DependenciesReceiver receiver ||
            (receiver?.Symbols == null))
        {
            return;
        }

        // group the fields by class, and generate the source
        foreach (var group in receiver.Symbols.GroupBy(fieldSymbol => fieldSymbol.ContainingType))
        {
            var classSource = ProcessClass(group.Key, group.ToList());
            context.AddSource($"{group.Key.Name}_Dependency.cs", SourceText.From(classSource, Encoding.UTF8));
        }
    }

    private string ProcessClass(INamedTypeSymbol classSymbol, List<ISymbol> symbols)
    {
        if (!classSymbol.ContainingSymbol.Equals(classSymbol.ContainingNamespace, SymbolEqualityComparer.Default))
        {
            return null; //TODO: issue a diagnostic that it must be top level
        }

        var namespaceName = classSymbol.ContainingNamespace.ToDisplayString();

        // begin building the generated source
        var source = new StringBuilder($@"
namespace {namespaceName}
{{
    public partial class {classSymbol.Name}
    {{
");
        source.Append($"        public {classSymbol.Name}(");
        source.Append(string.Join(", ", GetParams(symbols)));
        source.AppendLine(")");
        source.AppendLine("        {");
        source.AppendLine("            PreConstruct();");
        source.AppendLine();

        foreach (var symbol in symbols)
        {
            switch (symbol)
            {
                case IFieldSymbol field:
                    source.AppendLine($@"            this.{field.Name} = {field.Name.TrimStart('_')};");
                    break;
                case IPropertySymbol property:
                    var name = GetPropName(property, property.GetAttributes());
                    source.AppendLine($@"            {name} = {property.Name.ToCamelCase()};");
                    break;
            }
        }

        source.AppendLine();
        source.AppendLine("            PostConstruct();");
        source.AppendLine("        }");
        source.AppendLine();
        source.AppendLine("        partial void PreConstruct();");
        source.AppendLine("        partial void PostConstruct();");
        source.AppendLine("    }");
        source.AppendLine("}");
        return source.ToString();
    }

    private object? GetPropName(IPropertySymbol prop, ImmutableArray<AttributeData> attributes)
    {
        //System.Diagnostics.Debugger.Launch();

        var dependAttribute = attributes.FirstOrDefault(a => a.AttributeClass?.Name == "DependencyAttribute");
        if (dependAttribute == null)
        {
            return prop.Name;
        }
        var dependArg = dependAttribute.ConstructorArguments.FirstOrDefault();
        if (dependArg.IsNull || dependArg.Kind != TypedConstantKind.Primitive)
        {
            return prop.Name;
        }

        var altName = dependArg.Value as string;
        if (string.IsNullOrWhiteSpace(altName))
        {
            return prop.Name;
        }
        return altName;
    }

    private string[] GetParams(List<ISymbol> symbols)
    {
        var variables = new string[symbols.Count];
        for (var i = 0; i < symbols.Count; i++)
        {
            var symbol = symbols[i];
            switch (symbol)
            {
                case IFieldSymbol field:
                    variables[i] = $@"{field.Type} {field.Name.TrimStart('_')}";
                    break;
                case IPropertySymbol property:
                    variables[i] = $@"{property.Type} {property.Name.ToCamelCase()}";
                    break;
            }
        }
        return variables;
    }
}
