using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using SourceDepend.Extensions;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Linq;
using System.Text;

namespace SourceDepend.CodeGenerators
{
    internal static class DependencyClassCodeGenerator
    {
        internal static string Generate(INamedTypeSymbol classSymbol, List<ISymbol> symbols, List<ISymbol>? baseSymbols)
        {
            var namespaceName = classSymbol.ContainingNamespace.ToDisplayString();

            var hasNameSpace = !classSymbol.ContainingNamespace.IsGlobalNamespace;

            var sealedString = classSymbol.IsSealed ? "sealed " : "";
            var abstractString = classSymbol.IsAbstract ? "abstract " : "";
            var accessibilityKeyword = SyntaxFacts.GetText(classSymbol.DeclaredAccessibility);

            string typeArgumentsString = classSymbol.IsGenericType ?
                $"<{string.Join(",", classSymbol.TypeArguments.Select(t => t.ToDisplayString(SymbolDisplayFormat.MinimallyQualifiedFormat)))}>" :
                "";

            var spaces = hasNameSpace ? "    " : "";

            // begin building the generated source
            var source = new StringBuilder($@"// <auto-generated/>
#pragma warning disable
#nullable enable
");

            if (hasNameSpace)
            {
                source.AppendLine($"namespace {namespaceName}");
                source.AppendLine("{");
            }

            source.AppendLine($"{spaces}/// <inheritdoc/>");
            source.AppendLine($"{spaces}{accessibilityKeyword} {abstractString}{sealedString}partial class {classSymbol.Name}{typeArgumentsString}");
            source.AppendLine($"{spaces}{{");

            _ = source.Append($"{spaces}    public {classSymbol.Name}(");
            _ = source.Append(string.Join(", ", GetParams(symbols)));
            if (baseSymbols is not null)
            {
                _ = source.Append(", ");
                _ = source.Append(string.Join(", ", GetParams(baseSymbols)));
            }
            _ = source.Append(")");
            if (baseSymbols is not null)
            {
                _ = source.Append(" : base(");
                _ = source.Append(string.Join(", ", GetBaseParams(baseSymbols)));
                _ = source.Append(")");
            }
            _ = source.AppendLine();
            _ = source.AppendLine($"{spaces}    {{");
            _ = source.AppendLine();
            _ = source.AppendLine("#if NET6_0_OR_GREATER");
            foreach (var symbol in symbols)
            {
                switch (symbol)
                {
                    case IFieldSymbol field:
                        _ = source.AppendLine($@"{spaces}        ArgumentNullException.ThrowIfNull({field.Name.TrimStart('_')});");
                        break;
                    case IPropertySymbol property:
                        var name = GetPropName(property, property.GetAttributes());
                        _ = source.AppendLine($@"{spaces}        ArgumentNullException.ThrowIfNull({property.Name.ToCamelCase()});");
                        break;
                }
            }
            _ = source.AppendLine("#endif");
            _ = source.AppendLine($"{spaces}        PreConstruct();");
            _ = source.AppendLine();

            foreach (var symbol in symbols)
            {
                switch (symbol)
                {
                    case IFieldSymbol field:
                        _ = source.AppendLine($@"{spaces}        this.{field.Name} = {field.Name.TrimStart('_')};");
                        break;
                    case IPropertySymbol property:
                        var name = GetPropName(property, property.GetAttributes());
                        _ = source.AppendLine($@"{spaces}        {name} = {property.Name.ToCamelCase()};");
                        break;
                }
            }

            _ = source.AppendLine();
            _ = source.AppendLine($"{spaces}        PostConstruct();");
            _ = source.AppendLine($"{spaces}    }}");
            _ = source.AppendLine();
            _ = source.AppendLine($"{spaces}    partial void PreConstruct();");
            _ = source.AppendLine($"{spaces}    partial void PostConstruct();");

            if (hasNameSpace)
            {
                _ = source.AppendLine("    }");
            }
            _ = source.AppendLine("}");
            return source.ToString();
        }

        private static object? GetPropName(IPropertySymbol prop, ImmutableArray<AttributeData> attributes)
        {
            //System.Diagnostics.Debugger.Launch();

            var dependAttribute = attributes.FirstOrDefault(a => a.AttributeClass?.Name == "DependencyAttribute");
            if (dependAttribute == null)
            {
                return prop.Name;
            }

            var dependArg = dependAttribute.ConstructorArguments.FirstOrDefault();
            if (dependArg.IsNull || dependArg.Kind != TypedConstantKind.Primitive)
            {
                return prop.Name;
            }

            var altName = dependArg.Value as string;
            return string.IsNullOrWhiteSpace(altName) ? prop.Name : (object?)altName;
        }

        private static string[] GetParams(List<ISymbol> symbols)
        {
            var variables = new string[symbols.Count];
            for (var i = 0; i < symbols.Count; i++)
            {
                var symbol = symbols[i];
                switch (symbol)
                {
                    case IFieldSymbol field:
                        variables[i] = $@"{field.Type} {field.Name.TrimStart('_')}";
                        break;
                    case IPropertySymbol property:
                        variables[i] = $@"{property.Type} {property.Name.ToCamelCase()}";
                        break;
                    case IParameterSymbol parameter:
                        variables[i] = $@"{parameter.Type} {parameter.Name.ToCamelCase()}";
                        break;
                }
            }

            return variables;
        }

        private static string[] GetBaseParams(List<ISymbol> symbols)
        {
            var variables = new string[symbols.Count];
            for (var i = 0; i < symbols.Count; i++)
            {
                var symbol = symbols[i];
                switch (symbol)
                {
                    case IFieldSymbol field:
                        variables[i] = field.Name.TrimStart('_');
                        break;
                    case IPropertySymbol property:
                        variables[i] = property.Name.ToCamelCase();
                        break;
                    case IParameterSymbol parameter:
                        variables[i] = parameter.Name.ToCamelCase();
                        break;
                }
            }

            return variables;
        }
    }
}
