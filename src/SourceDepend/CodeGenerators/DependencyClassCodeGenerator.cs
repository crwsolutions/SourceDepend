using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using SourceDepend.Extensions;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Linq;
using System.Text;

namespace SourceDepend.CodeGenerators
{
    internal static class DependencyClassCodeGenerator
    {
        internal static string Generate(INamedTypeSymbol classSymbol, List<ISymbol> symbols)
        {
            //if (!classSymbol.ContainingSymbol.Equals(classSymbol.ContainingNamespace, SymbolEqualityComparer.Default))
            //{
            //    return null; //TODO: issue a diagnostic that it must be top level
            //}

            var namespaceName = classSymbol.ContainingNamespace.ToDisplayString();
            var sealedString = classSymbol.IsSealed ? "sealed " : "";
            var accessibilityKeyword = SyntaxFacts.GetText(classSymbol.DeclaredAccessibility);

            // begin building the generated source
            var source = new StringBuilder($@"// <auto-generated/>
#pragma warning disable
#nullable enable
namespace {namespaceName}
{{
    /// <inheritdoc/>
    {accessibilityKeyword} {sealedString}partial class {classSymbol.Name}
    {{
");
            _ = source.Append($"        public {classSymbol.Name}(");
            _ = source.Append(string.Join(", ", GetParams(symbols)));
            _ = source.AppendLine(")");
            _ = source.AppendLine("        {");
            _ = source.AppendLine("            PreConstruct();");
            _ = source.AppendLine();

            foreach (var symbol in symbols)
            {
                switch (symbol)
                {
                    case IFieldSymbol field:
                        _ = source.AppendLine($@"            this.{field.Name} = {field.Name.TrimStart('_')};");
                        break;
                    case IPropertySymbol property:
                        var name = GetPropName(property, property.GetAttributes());
                        _ = source.AppendLine($@"            {name} = {property.Name.ToCamelCase()};");
                        break;
                }
            }

            _ = source.AppendLine();
            _ = source.AppendLine("            PostConstruct();");
            _ = source.AppendLine("        }");
            _ = source.AppendLine();
            _ = source.AppendLine("        partial void PreConstruct();");
            _ = source.AppendLine("        partial void PostConstruct();");
            _ = source.AppendLine("    }");
            _ = source.AppendLine("}");
            return source.ToString();
        }

        private static object? GetPropName(IPropertySymbol prop, ImmutableArray<AttributeData> attributes)
        {
            //System.Diagnostics.Debugger.Launch();

            var dependAttribute = attributes.FirstOrDefault(a => a.AttributeClass?.Name == "DependencyAttribute");
            if (dependAttribute == null)
            {
                return prop.Name;
            }

            var dependArg = dependAttribute.ConstructorArguments.FirstOrDefault();
            if (dependArg.IsNull || dependArg.Kind != TypedConstantKind.Primitive)
            {
                return prop.Name;
            }

            var altName = dependArg.Value as string;
            return string.IsNullOrWhiteSpace(altName) ? prop.Name : (object?)altName;
        }

        private static string[] GetParams(List<ISymbol> symbols)
        {
            var variables = new string[symbols.Count];
            for (var i = 0; i < symbols.Count; i++)
            {
                var symbol = symbols[i];
                switch (symbol)
                {
                    case IFieldSymbol field:
                        variables[i] = $@"{field.Type} {field.Name.TrimStart('_')}";
                        break;
                    case IPropertySymbol property:
                        variables[i] = $@"{property.Type} {property.Name.ToCamelCase()}";
                        break;
                }
            }

            return variables;
        }
    }
}
